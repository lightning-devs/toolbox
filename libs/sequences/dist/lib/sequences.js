"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const isEmpty_1 = require("lodash/isEmpty");
const fp_1 = require("awaity/fp");
const function_seeker_1 = require("@lightning-devs/function-seeker");
/**
 * This is a composer function capable of handle those functions that return promises as result
 *
 * @param {Array<Function>} functions   Functions to be composed
 * @returns {Function}                  Composed function ready to receive an initial value
 */
function asyncCompose(...functions) {
    return initialValue => {
        const reduced = fp_1.reduce((finalValue, currentFunction) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let currentValue = currentFunction(finalValue);
            if (currentValue instanceof Promise) {
                currentValue = yield currentValue;
            }
            return currentValue;
        }), initialValue);
        return reduced(functions);
    };
}
/**
 * Function capable of map using a function that returns Promises as values
 *
 * @param {Function} mapFunction                Function that will be map every element
 * @param {Array<any>} valueArray               Array to map
 * @returns {Array<any>|Promise<Array<any>>}    Returns an array of plain values or a Promise containing an array with the mapped values
 */
const map = mapFunction => valueArray => {
    const mappedValues = valueArray.map(mapFunction);
    const didItReturnPromises = mappedValues[0] instanceof Promise;
    if (didItReturnPromises) {
        return Promise.all(mappedValues);
    }
    return mappedValues;
};
/**
 * This function generate Transformers using a sequence and a functionSeeker
 *
 * @param {Sequence} sequences          An array of transformation objects
 * @param {Function} functionSeeker     A function that receives a functionName {string} and looks for it on its sources of functions
 * @returns {Promise<any>}              Returns a function that receives an initial value and transforms it using the sequence that it received as param
 */
function getTransformer(sequences, functionSeeker) {
    const functionsToBeComposed = sequences.map((sequence) => {
        const { type, apply } = sequence;
        const { using, params } = apply;
        const functionToApply = functionSeeker(using);
        if (!functionToApply) {
            throw new Error(`This function cannot be find ${using}, please review your sources of functions.`);
        }
        let partialFunction = functionToApply;
        if (!isEmpty_1.default(params)) {
            if (Array.isArray(params)) {
                partialFunction = functionToApply(...params);
            }
            else {
                partialFunction = functionToApply(params);
            }
        }
        if (type === 'map') {
            return map(partialFunction);
        }
        return partialFunction;
    });
    return asyncCompose(...functionsToBeComposed);
}
/**
 * Curried function capable of transform values to objects by using the transformations described by the sequences provided for every expected field
 *
 * @param {Function} functionSeeker     A function that receives a functionName {string} and looks for it on its sources of functions
 * @param {Object} fieldsParams        This object describes the fields that will be generated by using a sequence for every field
 * @param {any} currentValue           Value that will be used to create a new object using the fields sequences provided
 * @returns {Object}                    Object generated using the transformers created by the field sequences
 */
const getFieldsFunction = functionSeeker => fieldsParams => {
    const { fieldsSequences } = fieldsParams;
    const getFieldsTransformers = fp_1.reduce((fieldOperators, [key, fieldDefinition]) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const { sequence } = fieldDefinition;
        const transformer = !isEmpty_1.default(sequence) && (getTransformer(sequence, functionSeeker));
        const operator = (itemValue) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            if (!transformer)
                return 'Sequence Required';
            const transformedValue = yield transformer(itemValue);
            return isEmpty_1.default(transformedValue) ? '' : transformedValue;
        });
        fieldOperators[key] = operator || (() => '');
        return fieldOperators;
    }), {});
    const transformer = getFieldsTransformers(Object.entries(fieldsSequences));
    return (currentValue) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const fieldsTransformers = yield transformer;
        const getTransformedFields = fp_1.reduce((acc, key) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            acc[key] = yield fieldsTransformers[key](currentValue);
            return acc;
        }), {});
        return yield getTransformedFields(Object.keys(fieldsTransformers));
    });
};
/**
 * This is a 'only forward' function, that is going to be used as expression for our intern source of functions
 *
 * @param {any} returnValue   Value to be forwarded/returned
 * @returns {any}             The same value that was received as param
 */
const returns = (returnValue) => () => returnValue;
/**
 * Curried function that allows to use a Sequencer as a expression in a transformation sequence, consequently this is used as a part of an intern source of functions.
 *
 * @param {Array} sourceOfFunctions     An array with the sources of functions provided by the user
 * @param {Object} sequenceParams       An object with a sequence, required to create a transformer, and the currentValue from the sequence that is being runned in order to initiate a side sequence that will transform the current value
 * @returns {any}                       A new value generated by the transformer created using the params described before
*/
const getSequencerAsExpression = sourceOfFunctions => (sequenceParams) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { initialValues, currentValue: sequence } = sequenceParams;
    return yield getSequencer(...sourceOfFunctions)(sequence)({ initialValues });
});
/**
 * This is a curried function that works in different stages:
 * 1. Receives some sources of functions and returns a "Sequencer"
 * 2. The returned "Sequencer" receives a sequence of transformations and returns a "Transformer"
 * 3. This "Transformer" receives an initial value (the first value you described in your transformation sequence) and returns a new value transformed using the sequence you provided before
 *
 * @param {Array} sourcesOfFunctions    An array containing multiple objects whose properties' structure is a key as the function name and its value is a curried function
 * @param {Sequence} sequence           An array which contains various objects describing a transformation that will be performed in the sequence
 * @param {any} initialValue            The value that will be used to initiate the sequence of transformations
 * @returns {Promise<any>}              Using the params described before, this curried function will return a transformed value by using the sequence and the initial value
 */
function getSequencer(...sourcesOfFunctions) {
    return (sequence) => ({ initialValues }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const sequencerExpression = getSequencerAsExpression(sourcesOfFunctions);
            const sources = [...sourcesOfFunctions, { returns, sequencer: sequencerExpression }];
            const fields = getFieldsFunction(function_seeker_1.getFunctionSeeker(sources));
            const functionSeeker = function_seeker_1.getFunctionSeeker([...sources, { fields }]);
            const transformer = getTransformer(sequence, functionSeeker);
            return yield transformer(initialValues);
        }
        catch (error) {
            console.error(error);
            throw error;
        }
    });
}
exports.getSequencer = getSequencer;
//# sourceMappingURL=sequences.js.map